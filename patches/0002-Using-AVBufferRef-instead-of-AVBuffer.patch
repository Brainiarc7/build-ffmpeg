From 860790ccdb4338c2dd44e513e54227bf2e2b1076 Mon Sep 17 00:00:00 2001
From: Kirill Savkov <k.savkov@inventos.ru>
Date: Fri, 29 Apr 2016 11:05:51 +0300
Subject: [PATCH 2/2] Using AVBufferRef instead of AVBuffer

---
 ffmpeg.c               | 25 ++++++++++---------------
 libavcodec/avcodec.h   | 27 ++++++++-------------------
 libavcodec/cue_xml.c   | 14 ++++++--------
 libavcodec/scte_35.c   | 17 ++++++++++-------
 libavcodec/utils.c     |  4 ++--
 libavformat/avformat.h | 14 --------------
 6 files changed, 36 insertions(+), 65 deletions(-)

diff --git a/ffmpeg.c b/ffmpeg.c
index e6283dc..f23f223 100644
--- a/ffmpeg.c
+++ b/ffmpeg.c
@@ -60,7 +60,6 @@
 #include "libavutil/bprint.h"
 #include "libavutil/time.h"
 #include "libavutil/threadmessage.h"
-#include "libavutil/buffer_internal.h"
 #include "libavformat/os_support.h"
 
 # include "libavfilter/avcodec.h"
@@ -2109,39 +2108,37 @@ static int transcode_data(InputStream *ist, AVPacket *pkt, int *got_output)
 {
     AVCodecContext *dec = ist->dec_ctx;
     enum AVCodecID in_codec_id = AV_CODEC_ID_NONE;
-    AVBuffer input;
-    AVBuffer output;
+    AVBufferRef *input = NULL;
     AVPacket outpkt;
     int ret, i;
 
     if (dec->codec)
         in_codec_id = dec->codec->id;
 
-    input.size = 0;
     update_benchmark(NULL);
     ret = avcodec_decode_data(dec, &input, pkt);
     update_benchmark("decode_data %d.%d", ist->file_index, ist->st->index);
 
-    if (ret < 0 || !input.size) {
+    if (ret < 0 || !input) {
         return ret;
     }
-    for (i = 0; i < nb_output_streams && input.size; i++) {
+    for (i = 0; i < nb_output_streams && input->size; i++) {
+        AVBufferRef *output = NULL;
         OutputStream *ost = output_streams[i];
 
         if (!check_output_constraints(ist, ost) || !ost->encoding_needed
             || ost->enc->type != AVMEDIA_TYPE_DATA)
             continue;
-        ret = avcodec_encode_data(output_streams[i]->enc_ctx, &input, &output, in_codec_id);
-        if ( ret >= 0 || output.size) {
+        ret = avcodec_encode_data(output_streams[i]->enc_ctx, (const AVBufferRef **)&input, &output, in_codec_id);
+        if ( ret >= 0 || output) {
             av_init_packet(&outpkt);
-            outpkt.data = output.data;
-            outpkt.size = output.size;
+            outpkt.data = output->data;
+            outpkt.size = output->size;
             write_frame(output_files[ost->file_index]->ctx, &outpkt, ost);
-            output.free(output.opaque, output.data);
         }
-        input.free(input.opaque, input.data);
-
+        av_buffer_unref(&output);
     }
+    av_buffer_unref(&input);
 
     return ret;
 
@@ -3001,8 +2998,6 @@ static int transcode_init(void)
                 break;
             case AVMEDIA_TYPE_DATA:
                 break;
-            case AVMEDIA_TYPE_DATA:
-                break;
             default:
                 abort();
                 break;
diff --git a/libavcodec/avcodec.h b/libavcodec/avcodec.h
index f9f66bf..6450143 100644
--- a/libavcodec/avcodec.h
+++ b/libavcodec/avcodec.h
@@ -3265,9 +3265,9 @@ typedef struct AVCodec {
      */
     void (*flush)(AVCodecContext *);
 
-    int (*decode_data)(AVCodecContext *,AVBuffer *output, const AVPacket *avpkt);
+    int (*decode_data)(AVCodecContext *, AVBufferRef **output, const AVPacket *avpkt);
 
-    int (*encode_data)(AVCodecContext *avctx, const AVBuffer *input, AVBuffer *output,
+    int (*encode_data)(AVCodecContext *avctx, const AVBufferRef **input, AVBufferRef **output,
                             enum AVCodecID in_codec_id);
 } AVCodec;
 
@@ -4228,19 +4228,14 @@ int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub,
  * Decode a Data packet.
  * Return a negative value on error, otherwise return the number of bytes used.
  * If no data was decoded then size parameter of output is zero.
- * In Output AVBuffer format of data parameter is based on the codec used, to use the 
- * data directly from output buffer one might need to use header file of
- * codec used as interface. This output buffer can be directly given to
- * avcodec_encode_data api if encoder support that decoder output.
  * 
  * @param avctx the codec context
- * @param[out] output The Preallocated AVBuffer in which the decoded data will
- *                    be stored, must be freed with free parameter of  AVBuffer
- *                    if size is not 0.
+ * @param[out] output Pointer to empty AVBufferRef in which the decoded data will
+ *                    be stored.
  * @param[in] avpkt The input AVPacket containing the input buffer.
  */
 int avcodec_decode_data(AVCodecContext *avctx,
-                                              AVBuffer *output,
+                                              AVBufferRef **output,
                                               const AVPacket *avpkt);
 /**
  * @defgroup lavc_parsing Frame parsing
@@ -4658,20 +4653,14 @@ int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size,
  * Encode Data Stream.
  *
  * Takes generic input buffer and writes to generic output buffer.
- * User cant give any input buffer blankly, Its user responsibility
- * to take care of encoder understanding, Data encoder are very 
- * specific to there input format. So either use FFmpeg decoder
- * to get the specific input buffer, or use the header files as
- * interface of encoder.
- * 
  *
  * @param avctx     codec context
- * @param[in]  input  Preallocated input Buffer.
- * @param[out] output Preallocated input Buffer.
+ * @param[in]  input  Pointer to AVBufferRef whith data to encode.
+ * @param[out] output Pointer to empty AVBufferRef.
  * @param[in]  in_codec_id   codec id of input buffer 
  * @return          0 on success, negative error code on failure
  */
-int avcodec_encode_data(AVCodecContext *avctx,const AVBuffer *input, AVBuffer *output,
+int avcodec_encode_data(AVCodecContext *avctx, const AVBufferRef **input, AVBufferRef **output,
                             enum AVCodecID in_codec_id);
 
 
diff --git a/libavcodec/cue_xml.c b/libavcodec/cue_xml.c
index 490fe2e..5ab6f58 100644
--- a/libavcodec/cue_xml.c
+++ b/libavcodec/cue_xml.c
@@ -125,7 +125,7 @@ static int add_varval_pair_uint64_t(struct node* n,const char *var,const uint64_
     return add_varval_pair(n, var, val2);
 }
 
-static void write_tree_as_data(struct node* root, AVBuffer *data)
+static void write_tree_as_data(struct node* root, AVBufferRef **data)
 {
     AVBPrint buffer;
     struct node *tmp = root->child;
@@ -148,10 +148,8 @@ static void write_tree_as_data(struct node* root, AVBuffer *data)
          av_bprintf(&buffer, "</%s>\n", tmp->name);
          tmp = tmp->parent;
     }
-    data->data  = av_strdup(buffer.str);
-    data->size  = strlen(buffer.str);
-    data->free  = av_buffer_default_free;
-    data->flags = AV_BUFFER_FLAG_READONLY;
+    *data = av_buffer_create((uint8_t*)av_strdup(buffer.str), strlen(buffer.str),
+                               av_buffer_default_free, NULL, AV_BUFFER_FLAG_READONLY);
 
     av_log(NULL, AV_LOG_DEBUG, "%s\n",buffer.str);
     av_bprint_finalize( &buffer, NULL);
@@ -201,17 +199,17 @@ static av_cold int close_encoder(AVCodecContext *avctx)
     return 0;
 }
 
-static int encode(AVCodecContext *avctx, const AVBuffer *input, AVBuffer *output,
+static int encode(AVCodecContext *avctx, const AVBufferRef **input, AVBufferRef **output,
                             enum AVCodecID in_codec_id)
 {
-    struct scte_35_interface *interface;
+    const struct scte_35_interface *interface;
     struct node event;
     struct cue_xml_ctx *ctx = avctx->priv_data;
 
     if(in_codec_id != AV_CODEC_ID_SCTE_35)
         return -1;
 
-    interface = (struct scte_35_interface *)input->data;
+    interface = (const struct scte_35_interface *)(*input)->data;
     init_node(&event,"event");
     add_varval_pair_uint32_t(&event, "event_id", interface->event_id);
     add_varval_pair_uint32_t(&event, "duration", interface->duration);
diff --git a/libavcodec/scte_35.c b/libavcodec/scte_35.c
index 513ed7d..0a0e1da 100644
--- a/libavcodec/scte_35.c
+++ b/libavcodec/scte_35.c
@@ -99,7 +99,7 @@ static int parse_schedule_cmd(struct scte_35_ctx *ctx, const uint8_t *buf)
 /**
      @return length of buffer used
  */
-static int parse_insert_cmd(struct scte_35_ctx *ctx, const uint8_t *buf, AVBuffer *output)
+static int parse_insert_cmd(struct scte_35_ctx *ctx, const uint8_t *buf, AVBufferRef **output)
 {
     GetBitContext gb;
     int ret;
@@ -107,12 +107,8 @@ static int parse_insert_cmd(struct scte_35_ctx *ctx, const uint8_t *buf, AVBuffe
     struct scte_35_interface *iface;
 
     iface = av_mallocz(sizeof(struct scte_35_interface));
-    if(!iface)
+    if (!iface)
         return AVERROR(ENOMEM);
-    output->data = (uint8_t*)iface;
-    output->size = sizeof(struct scte_35_interface);
-    output->free  = av_buffer_default_free;
-    output->flags = AV_BUFFER_FLAG_READONLY;
 
     av_log(ctx, AV_LOG_DEBUG, "Insert cmd\n");
     ctx->event_id = AV_RB32(buf);
@@ -175,6 +171,13 @@ static int parse_insert_cmd(struct scte_35_ctx *ctx, const uint8_t *buf, AVBuffe
     ctx->avail_expect = *buf++;
     av_log(ctx, AV_LOG_DEBUG, "avail_expect  = %hhd\n", ctx->avail_expect);
 
+    *output = av_buffer_create((uint8_t*)iface, sizeof(struct scte_35_interface),
+                               av_buffer_default_free, NULL, AV_BUFFER_FLAG_READONLY);
+    if (!output) {
+        av_freep(iface);
+        return AVERROR(ENOMEM);
+    }
+
     return buf - sbuf;
 }
 static int parse_time_signal_cmd(struct scte_35_ctx *ctx, const uint8_t *buf)
@@ -190,7 +193,7 @@ static int parse_bandwidth_reservation_cmd(struct scte_35_ctx *ctx, const uint8_
     return buf - sbuf;
 }
 
-static int decode(AVCodecContext *avctx, AVBuffer *output,
+static int decode(AVCodecContext *avctx, AVBufferRef **output,
                                               const AVPacket *avpkt)
 {
     struct scte_35_ctx *ctx = avctx->priv_data;
diff --git a/libavcodec/utils.c b/libavcodec/utils.c
index ea15606..ca844ab 100644
--- a/libavcodec/utils.c
+++ b/libavcodec/utils.c
@@ -2183,7 +2183,7 @@ int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size,
     avctx->frame_number++;
     return ret;
 }
-int avcodec_encode_data(AVCodecContext *avctx, const AVBuffer *input, AVBuffer *output,
+int avcodec_encode_data(AVCodecContext *avctx, const AVBufferRef **input, AVBufferRef **output,
                             enum AVCodecID in_codec_id)
 {
     int ret;
@@ -2642,7 +2642,7 @@ fail:
 }
 
 int attribute_align_arg avcodec_decode_data(AVCodecContext *avctx,
-                                              AVBuffer *output,
+                                              AVBufferRef **output,
                                               const AVPacket *avpkt)
 {
     AVCodecInternal *avci = avctx->internal;
diff --git a/libavformat/avformat.h b/libavformat/avformat.h
index de7b79a..df109bb 100644
--- a/libavformat/avformat.h
+++ b/libavformat/avformat.h
@@ -1673,14 +1673,6 @@ typedef struct AVFormatContext {
     AVCodec *data_codec;
 
     /**
-     * Forced data codec.
-     * This allows forcing a specific decoder, even when there are multiple with
-     * the same codec_id.
-     * Demuxing: Set by user via av_format_set_data_codec (NO direct access).
-     */
-    AVCodec *data_codec;
-
-    /**
      * Number of bytes to be written as padding in a metadata header.
      * Demuxing: Unused.
      * Muxing: Set by user via av_format_set_metadata_header_padding.
@@ -1731,12 +1723,6 @@ typedef struct AVFormatContext {
      * - demuxing: Set by user.
      */
     uint8_t *dump_separator;
-
-    /**
-     * Forced Data codec_id.
-     * Demuxing: Set by user.
-     */
-    enum AVCodecID data_codec_id;
 } AVFormatContext;
 
 int av_format_get_probe_score(const AVFormatContext *s);
-- 
1.9.1

